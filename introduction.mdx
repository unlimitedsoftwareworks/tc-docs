
# Introduction

Type-C is a versatile and high-performance programming language tailored for performance-intensive applications, such as user interfaces, games, and web services, etc. While Type-C can be embedded in various applications as a scripting language or run on resource-constrained devices, it truly excels in scenarios where speed and efficiency are paramount. In today's programming landscape, languages are evolving to address specific challenges and enforce robust patterns that were once mere guidelines. The increasing complexity of modern software, often reliant on numerous third-party libraries, necessitates stricter language features and practices. Type-C is no exception to this trend. It is designed with a clear philosophy and specific goals, which may resonate with some developers and not with others. The language draws inspiration from a variety of sources, including C, Java, and TypeScript. TypeScript's powerful type inference engine, Java's structure, and C's straightforwardness have all played a role in shaping Type-C. The primary aim of Type-C is to offer an enjoyable, expressive, and efficient programming experience. While it does not prioritize top-notch real-time performance or the absolute simplicity of writing, it enforces specific design patterns that contribute to robust and maintainable enterprise-grade software (hopefully).

The remaining of this documentation is structured as follows:
1. Hello, World!: A simple program to get you started.
2. Design Goal of Type-C: A bit of philosophy on why Type-C was created and how its features where selected.
3. Algorithms Implementation: A few examples of how to implement algorithms in Type-C.
4. Basics: The basic syntax of Type-C, program sekeleton, functions, etc.
5. Data Types: The data types available in Type-C.
    1. Basic Data Types
    2. Structures
    3. Enums
    4. Variants
    5. Arrays
    6. Function Types
    7. Join Types
    8. Concurrency Data Types
    9. Nullables

6. Interface Oriented Programming: How Type-C prefers to be behavior oriented rather than data oriented.
7. Expressions: The different types of expressions in Type-C.
8. Statements: The different types of statements in Type-C.
9. Type System: Explains Duck typing and when it is applicable
10. Type Casting: How to cast between different types in Type-C.
11. Type Compatibility: How to check if two types are compatible.
12. Pattern Matching: How to match patterns in Type-C.
13. Foreign Function Interface: How to call C functions from Type-C.
14. Non-Blocking: How non-blocking io operations are done in Type-C.
15. Concurrency: How to use concurrency in Type-C.
