Promise DataType
===

The best way to describe promise, is that they are the same as a regular JavaScript object, except they are built-in data types within the language.

A promise represent a piece of data that will be available in the future. A promise can be awaited, or assigned a callback function to be executed when the data is available, or simply ignored.

```tc
from std.fs import writeAsync
from std.io import println

fn main(args: String[]) {
    let content = "Hello, World!"
    let done: promise<u32> = writeAsync("hello.txt", content)
    done.then(fn(res: u32) {
        if res == 0 {
            println("File written successfully!")
        } else {
            println("Failed to write file! Error code" + res)
        }
    })

    return 0;
}
```

Now in this snippet, it is not an issue that the main process exists while we have an Async operation running, the VM will make sure everything is complete before completely shutting down the VM process. The main issue is that ideally, we would return an error instead of 0 if the write fails. Assigning a callback function is not the way to handle it, since we can't return a value from a callback function back to the main. This is where the `await` keyword comes in.

```tc
from std.fs import writeAsync
from std.io import println

fn main(args: String[]) {
    let content = "Hello, World!"
    let res: u32 = await writeAsync("hello.txt", content)
    if res == 0 {
        println("File written successfully!")
    } else {
        println("Failed to write file! Error code" + res)
    }

    return 0;
}
```

The `await` keyword will pause the main process until the promise is resolved. Awaiting a `promise<T>` will return the value of type `T` that the promise resolves to. Error handeling is left to the user, meaning, there is no `reject` of a promise. If you want to model an error, you can return an error code, or a `variant` type.

```tc
type WriteResponse = variant {
    Ok,
    Error(reason: String)
}
```